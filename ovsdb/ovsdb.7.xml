<?xml version="1.0" encoding="utf-8"?>
<manpage program="ovsdb" section="7" title="OVSDB">
  <h1>Name</h1>
  <p>ovsdb -- Open vSwitch Database</p>

  <h1>Description</h1>
  <p>
    OVSDB, the Open vSwitch Database, is a network database system.  Schemas in
    OVSDB specify the tables in a database and their columns' types and can
    include data, uniqueness, and referential integrity constraints.  OVSDB
    offers atomic, consistent, isolated, durable transactions.  RFC 7047
    specifies the JSON-RPC based protocol that OVSDB clients and servers use to
    communicate.
  </p>

  <p>
    The OVSDB protocol is well suited for state synchronization because it
    allows each client to monitor the contents of a whole database or a subset
    of it.  Whenever a monitored portion of the database changes, the server
    tells the client what rows were added or modified (including the new
    contents) or deleted.  Thus, OVSDB clients can easily keep track of the
    newest contents of any part of the database.
  </p>

  <p>
    While OVSDB is general-purpose and not particularly specialized for use
    with Open vSwitch, Open vSwitch does use it for multiple purposes.  The
    leading use of OVSDB is for configuring and monitoring
    <code>ovs-vswitchd</code>(8), the Open vSwitch switch daemon, using the
    schema documented in <code>ovs-vswitchd.conf.db</code>(5).  The Open
    Virtual Network (OVN) sub-project of OVS uses two OVSDB schemas, documented
    in <code>ovn-nb</code>(5) and <code>ovn-sb</code>(5).  Finally, Open
    vSwitch includes the ``VTEP'' schema, documented in <code>vtep</code>(5)
    that many third-party hardware switches support for configuring VXLAN,
    although OVS itself does not directly use this schema.
  </p>

  <p>
    The OVSDB protocol specification allows independent, interoperable
    implementations of OVSDB to be developed.  Open vSwitch includes a OVSDB
    server implementation named <code>ovsdb-server</code>(1), which supports
    several protocol extensions documented in its manpage, and a basic
    command-line OVSDB client named <code>ovsdb-client</code>(1), as well as
    OVSDB client libraries for C and for Python.  Open vSwitch documentation
    often speaks of these OVSDB implementations in Open vSwitch as simply
    ``OVSDB,'' even though that is distinct from the OVSDB protocol; we make
    the distinction explicit only when it might otherwise be unclear from the
    context.
  </p>

  <p>
    In addition to these generic OVSDB server and client tools, Open vSwitch
    includes tools for working with databases that have specific schemas:
    <code>ovs-vsctl</code> works with the <code>ovs-vswitchd</code>
    configuration database, <code>vtep-ctl</code> works with the VTEP database,
    <code>ovn-nbctl</code> works with the OVN Northbound database, and so on.
  </p>

  <p>
    RFC 7047 specifies the OVSDB protocol but it does not specify an on-disk
    storage format.  Open vSwitch includes <code>ovsdb-tool</code>(1) for
    working with its own on-disk database format.  The most notable feature of
    this format is that <code>ovsdb-tool</code>(1) makes it easy for users to
    print the transactions that have changed a database since the last time it
    was compacted.  This feature is often useful for troubleshooting.
  </p>

  <h1>Schemas</h1>

  <p>
    Schemas in OVSDB have a JSON format that is specified in RFC 7047.  They
    are often stored in files with an extension <code>.ovsschema</code>.  An
    on-disk database in OVSDB includes a schema and data, embedding both into a
    single file.  The Open vSwitch utility <code>ovsdb-tool</code> has commands
    that work with schema files and with the schemas embedded in database
    files.
  </p>

  <p>
    An Open vSwitch schema has three important identifiers.  The first is its
    name, which is also the name used in JSON-RPC calls to identify a database
    based on that schema.  For example, the schema used to configure Open
    vSwitch has the name <code>Open_vSwitch</code>.  Schema names begin with a
    letter or an underscore, followed by any number of letters, underscores, or
    digits.  The <code>ovsdb-tool</code> commands <code>schema-name</code> and
    <code>db-name</code> extract the schema name from a schema or database
    file, respectively.
  </p>

  <p>
    An OVSDB schema also has a version of the form
    <code><var>x</var>.<var>y</var>.<var>z</var></code>,
    e.g. <code>1.2.3</code>.  Schemas managed within the Open vSwitch project
    manage version numbering in the following way (but OVSDB does not mandate
    this approach).  Whenever we change the database schema in a non-backward
    compatible way (e.g. when we a column or a table), we increment
    <var>x</var> and set <var>y</var> and <var>z</var> to 0.  When we change
    the database schema in a backward compatible way (e.g. when we add a new
    column), we increment <var>y</var> and set <var>z</var> to 0.  When we
    change the database schema cosmetically (e.g. we reindent its syntax), we
    increment <var>z</var>.  The <code>ovsdb-tool</code> commands
    <code>schema-version</code> and <code>db-version</code> extract the schema
    version from a schema or database file, respectively.
  </p>

  <p>
    Very old OVSDB schemas do not have a version, but RFC 7047 mandates it.
  </p>

  <p>
    An OVSDB schema optionally has a ``checksum.''  RFC 7047 does not specify
    the use of the checksum and recommends that clients ignore it.  Open
    vSwitch uses the checksum to remind developers to update the version: at
    build time, if the schema's embedded checksum, ignoring the checksum field
    itself, does not match the schema's content, then it fails the build with a
    recommendation to update the version and the checksum.  Thus, a developer
    who changes the schema, but does not update the version, receives an
    automatic reminder.  In practice this has been an effective way to ensure
    compliance with the version number policy.  The <code>ovsdb-tool</code>
    commands <code>schema-cksum</code> and <code>db-cksum</code> extract the
    schema checksum from a schema or database file, respectively.
  </p>

  <h1>Service Models</h1>

  <p>
    OVSDB supports three service models for databases: <dfn>standalone</dfn>,
    <dfn>active-backup</dfn>, and <dfn>clustered</dfn>.  The service models
    provide different compromises among consistency, availability, and
    partition tolerance.  They also differ in the number of servers required
    and in terms of performance.  The standalone and active-backup database
    service models share one on-disk format, and clustered databases use a
    different format, but the OVSDB programs work with both formats.
  </p>

  <p>
    RFC 7047, which specifies the OVSDB protocol, does not mandate or specify
    any particular service model.
  </p>

  <p>
    The following sections describe the individual service models.
  </p>

  <h3>Standalone Database Service Model</h3>

  <p>
    A <dfn>standalone</dfn> database runs a single server.  If the server stops
    running, the database becomes inaccessible, and if the server's storage is
    lost or corrupted, the database's content is lost.  This service model is
    appropriate when the database controls a process or activity to which it is
    linked via ``fate-sharing.''  For example, an OVSDB instance that controls
    an Open vSwitch virtual switch daemon, <code>ovs-vswitchd</code>, is a
    standalone database because a server failure would take out both the
    database and the virtual switch.
  </p>

  <p>
    To set up a standalone database, use <code>ovsdb-tool create</code> to
    create a database file, then run <code>ovsdb-server</code> to start the
    database service.
  </p>

  <h3>Active-Backup Database Service Model</h3>

  <p>
    An <dfn>active-backup</dfn> database runs two servers (on different hosts).
    At any given time, one of the servers is designated with the
    <dfn>active</dfn> role and the other the <dfn>backup</dfn> role.  An active
    server behaves just like a standalone server.  A backup server makes
    an OVSDB connection to the active server and uses it to continuously
    replicate its content as it changes in real time.  OVSDB clients can
    connect to either server but only the active server allows data
    modification or lock transactions.
  </p>

  <p>
    Setup for an active-backup database starts from a working standalone
    database service, which is initially the active server.  On another node,
    to set up a backup server, create a database file with the same schema as
    the active server.  The initial contents of the database file do not
    matter, as long as the schema is correct, so <code>ovsdb-tool create</code>
    will work, as will copying the database file from the active server.  Then
    use <code>ovsdb-server --sync-from=<var>active</var></code> to start the
    backup server, where <var>active</var> is an OVSDB connection method (see
    <ref section="Connection Methods"/>, below) that connects to the active
    server.  At that point, the backup server will fetch a copy of the active
    database and keep it up-to-date until it is killed.
  </p>

  <p>
    When the active server in an active-backup server pair fails, an
    administrator can switch the backup server to an active role with the
    <code>ovs-appctl</code> command
    <code>ovsdb-server/disconnect-active-ovsdb-server</code>.  Clients then
    have read/write access to the now-active server.  Of course, administrators
    are slow to respond compared to software, so in practice external
    management software detects the active server's failure and changes the
    backup server's role.  For example, the <cite>Integration Guide for
    Centralized Control</cite> in the Open vSwitch documentation describes how
    to use Pacemaker for this purpose in OVN.
  </p>

  <p>
    Suppose an active server fails and its backup is promoted to active.
    If the failed server is revived, it must be started as a backup
    server.  Otherwise, if both servers are active, then they may start
    out of sync, if the database changed while the server was done, and
    they will continue to diverge over time.  This also happens if the
    software managing the database servers cannot reach the active server
    and therefore switches the backup to active, but other hosts can reach
    both servers.  These ``split-brain'' problems are unsolvable in
    general for server pairs.
  </p>

  <p>
    Compared to a standalone server, the active-backup service model
    somewhat increases availability, at a risk of split-brain.  It adds
    generally insignificant performance overhead.  On the other hand, the
    clustered service model, discussed below, requires at least 3 servers
    and has greater performance overhead, but it avoids the need for
    external management software and eliminates the possibility of
    split-brain.
  </p>

  <p>
    Open vSwitch 2.6 introduced support for the active-backup service model.
  </p>

  <h3>Clustered Database Service Model</h3>

  <p>
    A <dfn>clustered</dfn> database runs across 3 or 5 database servers (the
    <dfn>cluster</dfn>) on different hosts.  Servers in a cluster automatically
    synchronize writes within the cluster.  A 3-server cluster can remain
    available in the face of at most 1 server failure; a 5-server cluster
    tolerates up to 2 failures.
  </p>

  <p>
    Clusters larger than 5 servers will also work, with every 2 added
    servers allowing the cluster to tolerate 1 more failure, but
    performance decreases, especially write performance.  The number of
    servers should be odd: a 4- or 6-server cluster cannot tolerate more
    failures than a 3- or 5-server cluster, respectively.
  </p>

  <p>
    To set up a clustered database, first initialize it on a single node by
    running <code>ovsdb-tool create-cluster</code> and starting
    <code>ovsdb-server</code>.  To add a server to a cluster, run
    <code>ovsdb-tool join-cluster</code> on the new server and start
    <code>ovsdb-server</code>.  To remove a running server from a cluster, use
    <code>ovs-appctl</code> to invoke the <code>cluster/leave</code> command.
    When a server fails and cannot be recovered, e.g. because its hard disk
    crashed, or to otherwise remove a server that is down from a cluster, use
    <code>ovs-appctl</code> to invoke <code>cluster-kick</code> to make the
    remaining servers kick it out of the cluster.
  </p>

  <p>
    The above methods for adding and removing servers only work for healthy
    clusters, that is, for clusters with no more failures than their maximum
    tolerance.  For example, in a 3-server cluster, the failure of 2 servers
    prevents servers joining or leaving the cluster (as well as database
    access).  To prevent data loss or inconsistency, the preferred solution to
    this problem is to bring up enough of the failed servers to make the
    cluster healthy again, then if necessary remove any remaining failed
    servers and add new ones.  If this cannot be done, though, use
    <code>ovs-appctl</code> to invoke <code>cluster/leave --force</code> on a
    running server.  This command forces the server to which it is directed to
    leave its cluster and form a new single-node cluster that contains only
    itself.  The data in the new cluster may be inconsistent with the former
    cluster: transactions not yet replicated to the server will be lost, and
    transactions not yet applied to the cluster may be committed.  Afterward,
    any servers in its former cluster will regard the server to have failed.
  </p>

  <p>
    The servers in a cluster synchronize data over a cluster management
    protocol that is specific to Open vSwitch; it is not the same as the OVSDB
    protocol specified in RFC 7047.  For this purpose, a server in a cluster is
    tied to a particular IP address and TCP port, which is specified in the
    <code>ovsdb-tool</code> command that creates or joins the cluster.  The TCP
    port used for clustering must be different from that used for OVSDB
    clients.  To change the port or address of a server in a cluster, first
    remove it from the cluster, then add it back with the new address.
  </p>

  <p>
    To upgrade the <code>ovsdb-server</code> processes in a cluster from one
    version of Open vSwitch to another, upgrading them one at a time will keep
    the cluster healthy during the upgrade process.  (This is different from
    upgrading a database schema, which is covered later under <ref
    section="Upgrading or Downgrading a Database"/>.)
  </p>

  <p>
    Open vSwitch 2.8 introduced support for the clustered service model.
  </p>

  <h2>Database Replication</h2>

  <p>
    OVSDB can layer <dfn>replication</dfn> on top of any of its service models.
    Replication, in this context, means to make, and keep up-to-date, a
    read-only copy of the contents of a database (the <code>replica</code>).
    One use of replication is to keep an up-to-date backup of a database.  A
    replica used solely for backup would not need to support clients of its
    own.  A set of replicas that do serve clients could be used to scale out
    read access to the primary database.
  </p>

  <p>
    A database replica is set up in the same way as a backup server in an
    active-backup pair, with the difference that the replica is never promoted
    to an active role.
  </p>

  <p>
    Open vSwitch 2.6 introduced support for database replication.
  </p>

  <h1>Connection Methods</h1>

  <p>
    An OVSDB <dfn>connection method</dfn> is a string that specifies how to
    make a JSON-RPC connection between an OVSDB client and server.  Connection
    methods are part of the Open vSwitch implementation of OVSDB and not
    specified by RFC 7047.  <code>ovsdb-server</code> uses connection methods
    to specify how it should listen for connections from clients and
    <code>ovsdb-client</code> uses them to specify how it should connect to a
    server.  Connections in the opposite direction, where
    <code>ovsdb-server</code> connects to a client that is configured to listen
    for an incoming connection, are also possible.
  </p>

  <p>
    Connection methods are classified as <dfn>active</dfn> or
    <dfn>passive</dfn>.  An active connection method makes an outgoing
    connection to a remote host; a passive connection method listens for
    connection from remote hosts.  The most common arrangement is to configure
    an an OVSDB server with passive connection methods and clients with active
    ones, but the OVSDB implementation in Open vSwitch supports the opposite
    arrangement as well.
  </p>

  <p>
    OVSDB supports the following active connection methods:
  </p>

  <dl>
    <dt><code>ssl:<var>ip</var>:<var>port</var></code></dt>
    <dd>
      <p>
        The specified SSL or TLS <var>port</var> on the host at the given
        <var>ip</var>.
      </p>
    </dd>

    <dt><code>tcp:<var>ip</var>:<var>port</var></code></dt>
    <dd>
      <p>
        The specified TCP <var>port</var> on the host at the given
        <var>ip</var>.
      </p>
    </dd>

    <dt><code>unix:<var>file</var></code></dt>
    <dd>
      <p>
        On Unix-like systems, connect to the Unix domain server socket named
        <var>file</var>.
      </p>

      <p>
        On Windows, connect to a local named pipe that is represented by a file
        created in the path <var>file</var> to mimic the behavior of a Unix
        domain socket.
      </p>
    </dd>

    <dt><var>method1</var><code>, </code><var>method2</var><code>, </code>...<code>, </code><var>methodN</var></dt>
    <dd>
      <p>
        For a clustered database service to be highly available, a client must
        be able to connect to any of the servers in the cluster.  To do so,
        specify connection methods for each of the servers separated by commas
        (and optional spaces).
      </p>

      <p>
        In theory, if machines go up and down and IP addresses change in the
        right way, a client could talk to the wrong instance of a database.  To
        avoid this possibility, add <code>cid:<var>uuid</var></code> in the
        list of connection methods, where <var>uuid</var> is the cluster ID of
        the desired database cluster, as printed by <code>ovsdb-tool
        get-cid</code>.  This feature is optional.
      </p>
    </dd>
  </dl>

  <p>
    OVSDB supports the following passive connection methods:
  </p>

  <dl>
    <dt><code>pssl:<var>port</var></code></dt>
    <dt><code>pssl:<var>port</var>:<var>ip</var></code></dt>
    <dd>
      Listen on the given TCP <var>port</var> for SSL or TLS connections.  By
      default, connections are not bound to a particular local IP address and
      connections from IPv6 addresses are not accepted.  Specifying
      <var>ip</var> limits connections to those from the given IP.
    </dd>

    <dt><code>ptcp:<var>port</var></code></dt>
    <dt><code>ptcp:<var>port</var>:<var>ip</var></code></dt>
    <dd>
      Listen on the given TCP <var>port</var>.  By
      default, connections are not bound to a particular local IP address and
      connections from IPv6 addresses are not accepted.  Specifying
      <var>ip</var> limits connections to those from the given IP.
    </dd>

    <dt><code>punix:<var>file</var></code></dt>
    <dd>
      <p>
        On Unix-like systems, listens for connections on the Unix domain socket
        named <var>file</var>.
      </p>

      <p>
        On Windows, listens on a local named pipe, creating a named pipe
        <var>file</var> to mimic the behavior of a Unix domain socket.
      </p>
    </dd>
  </dl>

  <p>
    All IP-based connection methods accept IPv4 and IPv6 addresses.  DNS names
    are not accepted.  To specify an IPv6 address, wrap it in square brackets,
    e.g.  <code>ssl:[::1]:6640</code>.
  </p>

  <p>
    The <var>port</var> may be omitted from connection methods that use a port
    number.  The default <var>port</var> for TCP-based connection methods is
    6640, e.g. <code>pssl:</code> is equivalent to <code>pssl:6640</code>.  In
    Open vSwitch prior to version 2.4.0, the default port was 6632.  To avoid
    incompatibility between older and newer versions, we encourage users to
    specify a port number.
  </p>

  <p>
    The <code>ssl</code> and <code>pssl</code> connection methods requires
    additional configuration through <code>--private-key</code>,
    <code>--certificate</code>, and <code>--ca-cert</code> command line
    options.  Open vSwitch can be built without SSL support, in which case
    these connection methods are not supported.
  </p>

  <h1>Database Life Cycle</h1>

  <p>
    This section describes how to handle various events in the life cycle of
    a database using the Open vSwitch implementation of OVSDB.
  </p>

  <h2>Creating a Database</h2>

  <p>
    Creating and starting up the service for a new database was covered
    separately for each database service model in the <ref section="Service
    Models"/> section, above.
  </p>

  <h2>Backing Up and Restoring a Database</h2>

  <p>
    OVSDB is often used in contexts where the database contents are not
    particularly valuable.  For example, in many systems, the database for
    configuring <code>ovs-vswitchd</code> is essentially rebuilt from scratch
    at boot time.  It is not worthwhile to back up these databases.
  </p>

  <p>
    When OVSDB is used for valuable data, a backup strategy is worth
    considering.  One way is to use database replication, discussed above in
    <ref section="Database Replication"/>, which keeps an online, up-to-date
    copy of a database, possibly on a remote system.  This works with all OVSDB
    service models.
  </p>

  <p>
    A more common backup strategy is to periodically take and store a snapshot.
    For the standalone and active-backup service models, making a copy of the
    database file, e.g. using <code>cp</code>, effectively makes a snapshot,
    and because OVSDB database files are append-only, it works even if the
    database is being modified when the snapshot takes place.  This approach
    does not work for clustered databases (short of taking a snapshot of all
    the servers' database files at the same time).
  </p>

  <p>
    Another way to make a backup, which works with all OVSDB service models, is
    to use <code>ovsdb-client backup</code>, which connects to a running
    database server and outputs an atomic snapshot of its schema and content,
    in the same format used for standalone and active-backup databases.
  </p>

  <p>
    Multiple options are also available when the time comes to restore a
    database from a backup.  For the standalone and active-backup service
    models, one option is to stop the database server or servers, overwrite the
    database file with the backup (e.g. with <code>cp</code>), and then restart
    the servers.  Another way, which works with any service model, is to use
    <code>ovsdb-client restore</code>, which connects to a running database
    server and replaces the data in one of its databases by a provided
    snapshot.  Using <code>ovsdb-client restore</code> has the disadvantage
    that UUIDs of rows in the restored database will differ from those in the
    snapshot the OVSDB protocol does not allow clients to specify row UUIDs.
  </p>

  <p>
    None of these approaches save and restore data in columns that the schema
    designates as ephemeral.  This is by design: the designer of a schema only
    marks a column as ephemeral if it is acceptable for its data to be lost
    when a database server restarts.
  </p>

  <p>
    Clustering and backup serve different purposes.  Clustering increases
    availability, but it does not protect against data loss if, for example, a
    malicious or malfunctioning OVSDB client deletes or tampers with data.
  </p>

  <h2>Upgrading or Downgrading a Database</h2>

  <p>
    The evolution of a piece of software can require changes to the schemas of
    the databases that it uses.  For example, new features might require new
    tables or new columns in existing tables, or conceptual changes might
    require a database to be reorganized in other ways.  In some cases, the
    easiest way to deal with a change in a database schema is to delete the
    existing database and start fresh with the new schema, especially if the
    data in the database is easy to reconstruct.  But in many other cases, it
    is better to convert the database from one schema to another.
  </p>

  <p>
    The OVSDB implementation in Open vSwitch has built-in support for some
    simple cases of converting a database from one schema to another.  This
    support can handle changes that add or remove database columns or tables or
    that eliminate constraints (for example, changing a column that must have
    exactly one value into one that has one or more values).  It can also
    handle changes that add constraints or make them stricter, but only if the
    existing data in the database satisfies the new constraints (for example,
    changing a column that has one or more values into a column with exactly
    one value, if every row in the column has exactly one value).  The built-in
    conversion can cause data loss in obvious ways, for example if the new
    schema removes tables or columns, or indirectly, for example by deleting
    unreferenced rows in tables that the new schema marks for garbage
    collection.
  </p>

  <p>
    Converting a database can lose data, so it is wise to make a backup
    beforehand.
  </p>

  <p>
    To use OVSDB's built-in support for schema conversion with a standalone or
    active-backup database, first stop the database server or servers, then use
    <code>ovsdb-tool convert</code> to convert it to the new schema, and then
    restart the database server.
  </p>

  <p>
    OVSDB also supports online database schema conversion, for any of its
    database service models.  To convert a database online, use
    <code>ovsdb-client convert</code>.  The conversion is atomic, consistent,
    isolated, and durable.  The OVSDB protocol does not provide a way for the
    server to notify a client that a database's schema has changed, so
    currently <code>ovsdb-server</code> disconnects any clients connected when
    the conversion takes place.  Upon reconnction, clients will discover that
    the schema has changed.
  </p>

  <p>
    Schema versions and checksums (see <ref section="Schemas"/>, above) can
    give hints about whether a database needs to be converted to a new schema.
    If there is any question, though, the <code>needs-conversion</code> command
    on <code>ovsdb-tool</code> and <code>ovsdb-client</code> can provide a
    definitive answer.
  </p>

  <h2>Working with Database History</h2>

  <p>
    Both on-disk database formats that OVSDB supports are organized as a stream
    of transaction records.  Each record describes a change to the database as
    a list of rows that were inserted or deleted or modified, along with the
    details.  Therefore, in normal operation, a database file only grows, as
    each change causes another record to be appended at the end.  Usually, a
    user has no need to understand this file structure.  This section covers
    some exceptions.
  </p>

  <h3>Compacting Databases</h3>

  <p>
    If OVSDB database files were truly append-only, then over time they would
    grow without bound.  To avoid this problem, OVSDB can <dfn>compact</dfn> a
    database file, that is, replace it by a new version that contains only the
    current database contents, as if it had been inserted by a single
    transaction.  From time to time, <code>ovsdb-server</code> automatically
    compacts a database that grows much larger than its minimum size.
  </p>

  <p>
    Because <code>ovsdb-server</code> automatically compacts databases, it is
    usually not necessary to compact them manually, but OVSDB still offers a
    few ways to do it.  First, <code>ovsdb-tool compact</code> can compact a
    standalone or active-backup database that is not currently being served by
    <code>ovsdb-server</code> (or otherwise locked for writing by another
    process).  To compact any database that is currently being served by
    <code>ovsdb-server</code>, use <code>ovs-appctl</code> to send the
    <code>ovsdb-server/compact</code> command.  Each server in an active-backup
    or clustered database maintains its database file independently, so to
    compact all of them, issue this command separately on each server.
  </p>

  <h3>Viewing History</h3>

  <p>
    The <code>ovsdb-tool</code> utility's <code>show-log</code> command
    displays the transaction records in an OVSDB database file in a
    human-readable format.  By default, it shows minimal detail, but adding the
    option <code>-m</code> once or twice increases the level of detail.  In
    addition to the transaction data, it shows the time and date of each
    transaction and any ``comment'' added to the transaction by the client.
    The comments can be helpful for quickly understanding a transaction; for
    example, <code>ovs-vsctl</code> adds its command line to the transactions
    that it makes.
  </p>

  <p>
    The <code>show-log</code> command works with both OVSDB file formats, but
    the details of the output format differ.  For active-backup and clustered
    databases, the sequence of transactions in each server's log will differ,
    even at points when they reflect the same data.
  </p>

  <h3>Truncating History</h3>

  <p>
    It may occasionally be useful to ``roll back'' a database file to an
    earlier point.  Because of the organization of OVSDB records, this is easy
    to do.  Start by noting the record number <var>i</var> of the first record
    to delete in <code>ovsdb-tool show-log</code> output.  Each record is two
    lines of plain text, so trimming the log is as simple as running <code>head
    -n <var>j</var></code>, where <var>j</var> = 2<var>i</var>.
  </p>

  <h2>Corruption</h2>

  <p>
    When <code>ovsdb-server</code> opens an OVSDB database file, of any kind,
    it reads as many transaction records as it can from the file until it
    reaches the end of the file or it encounters a corrupted record.  At that
    point it stops reading and regards the data that it has read to this point
    as the full contents of the database file, effectively rolling the database
    back to an earlier point.
  </p>

  <p>
    Each transaction record contains an embedded SHA-1 checksum, which the
    server verifies as it reads a database file.  It detects corruption when a
    checksum fails to verify.  Even though SHA-1 is no longer considered secure
    for use in cryptography, it is acceptable for this purpose because it is
    not used to defend against malicious attackers.
  </p>

  <p>
    The first record in a standalone or active-backup database file specifies
    the schema.  <code>ovsdb-server</code> will refuse to work with such a
    database, or with a clustered database file with corruption in the first
    few records.  Delete and recreate such a database, or restore it from a
    backup.
  </p>

  <p>
    When <code>ovsdb-server</code> adds records to a database file in which it
    detected corruption, it first truncates the file just after the last good
    record.
  </p>

  <h1>See Also</h1>

  <p>RFC 7047, ``The Open vSwitch Database Management Protocol.''</p>

  <p>
    Open vSwitch implementations of generic OVSDB functionality:
    <code>ovsdb-server</code>(1),
    <code>ovsdb-client</code>(1),
    <code>ovsdb-tool</code>(1).
  </p>

  <p>
    Tools for working with databases that have specific OVSDB schemas:
    <code>ovs-vsctl</code>(8),
    <code>vtep-ctl</code>(8),
    <code>ovn-nbctl</code>(8),
    <code>ovn-sbctl</code>(8).
  </p>

  <p>
    OVSDB schemas for Open vSwitch and related functionality:
    <code>ovs-vswitchd.conf.db</code>(5),
    <code>vtep</code>(5),
    <code>ovn-nb</code>(5),
    <code>ovn-sb</code>(5).
  </p>
</manpage>
